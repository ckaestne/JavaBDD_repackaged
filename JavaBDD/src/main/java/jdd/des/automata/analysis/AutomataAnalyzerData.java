package jdd.des.automata.analysis;

import jdd.des.automata.*;
import jdd.util.*;
import jdd.util.math.*;
import jdd.graph.*;

/**
 * this class hold the information generated by a call
 * to AutomataAnalyzer.analyze()
 */

public class AutomataAnalyzerData {

	/** name of the fields used */
	private  static final String fields =
		"file\tautomata\tevents\tcomponents\tG-STATES.max\t" +
		"L-STATES.min\tL-STATES.max\tL-STATES.avg\tL-STATES.dev\t" +
		"L-EVENTS.min\tL-EVENTS.max\tL-EVENTS.avg\tL-EVENTS.dev\t" +
		"PCG.edges\tPCG.weight-sum\t" +
		"MST.edges\tMST.weight\t" +
		"VC.ED.nodes\tVC.MDG.nodes\t"+
		"Dep.min\tDep.max\tDep.agv\tDep.dev\tDep.min.name\tDep.max.name\t"+
		"Dep2.min\tDep2.max\tDep2.agv\tDep2.dev\tDep2.min.name\tDep2.max.name\t"+
		"EvProb.min\tEvProb.max\tEvProb.avg\tEvProb.dev\t" +
		"EvProb.min.name\tEvProb.max.name\t" +
		"EBF" +
		"";


	public String file;		/** name of the XML file, if any */
	public String internal_name;	/** name of the automata, taken from the file name */

	public int num_automata;	/** num of automata */
	public int num_events;		/** num of events in the alphabet */
	public int g_num_edges;		/** num of edges in the PCG graph */
	public int g_num_island;	/** number of components in the PCG graph */


	/** num of nodes in the vertex cover (MDG or ED heuristics ) */
	public double  g_vcnodes_mdg, g_vcnodes_ed;


	public double max_states;	/** max (i.e. theoretical) num of states */
	public double g_sum_weight; /** sum of edge-weights in the PCG graph */
	public double g_mst_weight, g_mst_edges; /** num of and total weight of MST edges */

	/** level-1 dependency */
	public double level1_dep_min, level1_dep_max, level1_dep_avg, level1_dep_dev;

	/** level-2 dependency */
	public double level2_dep_min, level2_dep_max, level2_dep_avg, level2_dep_dev;

	/** event probability */
	public double event_prob_min, event_prob_max, event_prob_avg, event_prob_dev;

	/** level-1 dependency, automata names */
	public String level1_dep_min_name, level1_dep_max_name;

	/** level-2 dependency, automata names */
	public String level2_dep_min_name, level2_dep_max_name;

	/** event probability, event names */
	public String event_prob_min_name, event_prob_max_name;

	/** num-of-states distribution in the automata */
	public double state_dist_min, state_dist_max, state_dist_avg, state_dist_dev;

	/** num-of-events distribution in the automaton alphabets */
	public double event_dist_min, event_dist_max, event_dist_avg, event_dist_dev;


	public double estimated_branching_factor; /** branching-factor estimation */

	public Graph pcg;		/** the PCG graph */
	public Graph mst;		/** the PCG graph with its MST edges high-lighted */
	public Topology wto;	/** Weak-topological-order of the PCG graph */


	/**
	 * print the name of the columns
	 */
	public static void printHeader() {
		JDDConsole.out.println(fields);
	}

	/** print the data in this object, TAB-seperated */
	public void print() {
		JDDConsole.out.print(internal_name + "\t" + num_automata + "\t" +  num_events + "\t" + g_num_island + "\t" + max_states + "\t");
		JDDConsole.out.print(state_dist_min + "\t" + state_dist_max + "\t" + state_dist_avg + "\t" +  state_dist_dev + "\t");
		JDDConsole.out.print(event_dist_min + "\t" + event_dist_max + "\t" + event_dist_avg + "\t" +  event_dist_dev + "\t");
		JDDConsole.out.print(g_num_edges + "\t" + g_sum_weight + "\t");
		JDDConsole.out.print(g_mst_edges + "\t" + g_mst_weight + "\t");
		JDDConsole.out.print(g_vcnodes_mdg + "\t" + g_vcnodes_ed + "\t");

		JDDConsole.out.print(level1_dep_min + "\t" + level1_dep_max + "\t" + level1_dep_avg + "\t" +  level1_dep_dev + "\t" + level1_dep_min_name + "\t" + level1_dep_max_name + "\t");
		JDDConsole.out.print(level2_dep_min + "\t" + level2_dep_max + "\t" + level2_dep_avg + "\t" +  level2_dep_dev + "\t" + level2_dep_min_name + "\t" + level2_dep_max_name + "\t");
		JDDConsole.out.print(event_prob_min + "\t" + event_prob_max + "\t" + event_prob_avg + "\t" +  event_prob_dev + "\t" + level2_dep_min_name + "\t" + event_prob_max_name + "\t");
		JDDConsole.out.print(""+estimated_branching_factor);
		JDDConsole.out.println();
	}

	/** print the data in this object, human readable*/
	public void printOne() {
		JDDConsole.out.println("Name: " + internal_name + ", " + num_automata + " automata with " +  num_events + " events, max states: " + max_states);


		JDDConsole.out.println("State distribution: " + Digits.getWithDecimals( state_dist_min, 2) + "/" + Digits.getWithDecimals( state_dist_avg, 2) + "/" + Digits.getWithDecimals( state_dist_max, 2) + ", std-dev: " +  state_dist_dev );
		JDDConsole.out.println("Event distribution: " + Digits.getWithDecimals( event_dist_min, 2) + "/" + Digits.getWithDecimals( event_dist_avg, 2) + "/" + Digits.getWithDecimals( event_dist_max, 2) + ", std-dev: " +  event_dist_dev );

		JDDConsole.out.println("PCG: " + g_num_edges + " edges, weight-sum = " + g_sum_weight + ", components: " + g_num_island);
		JDDConsole.out.println("PCG-MST: " + Digits.getPercent( g_mst_edges) + "% edges, weight = " + g_mst_weight );
		JDDConsole.out.println("PCG-vertex cover: " + Digits.getPercent( g_vcnodes_mdg )+ "% nodes with MDG and " + Digits.getPercent( g_vcnodes_ed ) + "% nodes with ED heuristics");


		JDDConsole.out.println("LD1-dep: " + Digits.getPercent( level1_dep_min) + "/" + Digits.getPercent( level1_dep_avg) + "/" + Digits.getPercent( level1_dep_max) + "%, std-dev: " +  level1_dep_dev);
		JDDConsole.out.println("LD2-dep: " + Digits.getPercent( level2_dep_min) + "/" + Digits.getPercent( level2_dep_avg) + "/" + Digits.getPercent( level2_dep_max) + "%, std-dev: " +  level2_dep_dev);
		JDDConsole.out.println("Event-probability: " + Digits.getPercent( event_prob_min) + "/" + Digits.getPercent( event_prob_avg) + "/" + Digits.getPercent( event_prob_max) + "%, std-dev: " +  event_prob_dev);
		JDDConsole.out.println("Estimated branching-factor: " + estimated_branching_factor);
		JDDConsole.out.println();

	}

}

